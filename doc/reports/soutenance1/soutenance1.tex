\documentclass[a4paper,12pt]{article}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pslatex}
\usepackage{url}
\usepackage{graphicx}
\usepackage{lscape}
\selectlanguage{francais}


\title{Rapport de Soutenance 1}
\author{
Ihy Group : \\
deguil\_x (Xavier Deguillard)\\
genite\_n (Nicolas Geniteau)\\
sezer\_s (Stephane Sezer)\\
wagnac\_t (Teddy Wagnac)
}
\date{10 f\'evrier 2009}

\begin{document}

\maketitle

\newpage

\section*{Introduction}
Nous avons  décidé cette  année de  nous atteler  à la  réalisation d'un
codec audio.  L'orientation principale des projets de spé de cette année
étant  la recherche  et le  développement,  nous  avons  choisi  de nous
tourner vers les ondelettes qui seront notre base de travail.  En effet,
les ondelettes  étant un outil  mathématique relativement  récent (elles
datent du XXème siècle),  elles ne  sont pas encore largement utilisées.
Il existe  actuellement certains algorithmes  de compression vidéo,  par
exemple Dirac, leur implémentation par la BBC, mais rien de probant pour
le traitement du signal audio.\\
Notre nouveau codec révolutionnaire (du  moins nous l'espérons) se nomme
donc le  ihy,  pour deux raisons.  Premièrement parce  qu'``ihy'' est le
nom d'un dieu égyptien de la  musique,  et deuxièmement parce que ce mot
est compliqué à prononcer.\\
Ceci étant dit, entrons dans le vif du sujet.  Nous présenterons dans ce
rapport le travail accompli depuis  la validation du cahier des charges,
les problèmes  rencontrés et  leurs solutions,  ainsi  que le  travail à
accomplir pour la prochaine soutenance.

\newpage

\tableofcontents

\newpage

\section{Travail accompli}

	\subsection{Spécifications du format ihy}

	\subsection{Ondelette de Haar}

	\subsection{Interfaçage Caml/C}
Les ondelettes  étant faites  en Caml,  et  l'écriture ainsi  que divers
traitement réalisés en  C,  il nous fallait faire  transiter des données
entre le  C et le Caml.  Il  y eut plusieurs  étapes,  envoie de données
simple  au  Caml,   puis  envois  de  données  plus  complexe  et  enfin
récupération de ces données.\\

		\subsubsection{Envois de données simple}
Il s'agissait de  la première étape,  pour comprendre  comment on devait
pour interfacer le C et le  Caml.  Notre premier programme fût un simple
envoie de chaine  de caractères,  et affichage dans la  console de cette
chaine de caractère.\\
Le plus  dur fût de trouver  comment envoyer cette  chaine a Caml.  Pour
cela,  il  fallu  avant  tout  déclarer  la  fonction  Caml  comme étant
utilisable via un ``callback'' :
\begin{verbatim}
let _ =
  Callback.register "print_string" print
\end{verbatim}
Comme vous  pouvez le voir,  rien de  bien difficile à  mettre en place,
``print\_string''  était l'identifiant  extérieur  de  la  fonction Caml
``print''.   La  fonction   ``print''  était  désormais   utilisable  de
l'extérieur.\\
Il  fallait désormais  pouvoir l'utiliser  à partir  du C.  Heureusement
Caml fournit des fonctions pour nous aider.  Notamment les fonctions :
\begin{verbatim}
CAMLextern value * caml_named_value (char const * name);
CAMLextern value caml_callback (value closure, value arg);
\end{verbatim}
La première  renvoie un  pointeur sur la  fonction Caml  correspondant a
``name'',   la  seconde  appelle  la  fonction  ``closure''  avec  comme
paramètre ``arg''.  Mais  avant  de  pouvoir  utiliser ces fonction,  il
fallut ``initialiser'' Caml,  à l  l'aide de la fonction ``caml\_main'',
indispensable pour pouvoir exécuter du Caml.\\
La dernière  chose à  faire avant de  pouvoir appeler  le Caml  était de
transformer  les types  C en  type  Caml.  Cela  est  géré  par  le type
``value''  et  les  fonctions  associées.   Après  cela,  la  chaine  de
caractère était bien affichée par Caml.\\
Comme on peut le voir,  la mise en place de l'interface du coté Caml est
bien plus simple que du coté du C.\\

		\subsubsection{Envois et récupération de données complexes}
Maintenant que nous avions envoyer  une chaine de caractère,  il fallait
essayer d'envoyer des données plus intéressantes pour nous, c'est-à-dire
un tableau de  données.  Les ``ennuis'' commencèrent.  Premièrement,  le
type ``array'' de Caml n'est pas  compatible avec les tableaux de C,  il
nous  fallu  utiliser  le  module  ``Bigarray''  de  Caml,  qui  lui est
compatible avec  les tableaux du  C (il fallait  néanmoins convertir ces
derniers en ``value'').  Deuxièmement,  dès que l'on touchait au tableau
du coté de Caml,  le programme avait une ``segmentation fault'',  plutôt
gênant\ldots En fait, dans le cas des entiers (plus précisément, de tout
sauf  des  nombres  flottants),  Caml  les  code  sur  31bits  (sur  une
architecture 32bits) et non pas sur  32bits comme le C,  il y avait donc
un soucis à  l'écriture.  Il fallait donc utiliser le  type ``Int32'' de
Caml pour modifier le contenu du tableau,  le code devient très moche et
quasi illisible.  Heureusement pour nous, les ondelettes travaillent sur
des nombres flottants qui est codé de la même façon en C et en Caml.\\
Nous pouvions  désormais envoyer des  tableaux de flottants  à Caml,  et
Caml pouvait modifier à sa  guise le contenu du tableau.  Étape suivante
: récupérer le tableau modifié.  Pour cela,  rien de bien compliqué,  la
fonction ``caml\_callback'' vue précédemment  nous renvoie sous forme de
``value'' le résultat de la fonction appelée.  Il suffisait désormais de
récupérer le tableau contenu dans le ``value'',  et encore une fois Caml
fournit une fonction (ou plutôt une macro ici) : ``Data\_bigarray\_val''
qui  renvois  le  tableau  contenu  dans  un  ``value''  représentant un
``bigarray''.

	\subsection{Algorithme de Huffman}

	\subsection{Lecture de son}

	\subsection{Premières étapes de threading}
De nos jours,  les processeurs ont de plus de plus de cœurs, ils peuvent
donc exécuter de plus en plus de tâches simultanément, et donc faire des
traitements  plus  rapides  si   cette  exécution  simultanée  est  bien
pensée.\\
La compression audio est particulièrement bien adaptée à cette exécution
simultanée,  dites ``concurrentielle''.  En  effet la  compression d'une
partie de la  musique ne dépend pas du  résultat d'une partie précédente
(dans notre  cas).  On peut  donc mettre  en place  des ``threads'',  un
thread  permettant   cette  execution  simultanée  au   sein  d'un  même
programme,  chaque thread  calculant une partie de  la musique.  Dans la
pratique,  un thread ne calcule pas uniquement une partie mais plusieurs
petites  parties,  ceci pour  réduire encore  la durée  d'un traitement.
Pour  illustrer  cela,  prenons un  exemple  :  utilisons  2  threads et
considérons que la  première partie de la musique met  deux fois plus de
temps  que  la deuxième  partie.  Le  premier  thread  va  compresser la
première partie,  et le deuxième la deuxième, comme on peut s'en douter,
le deuxième  thread mettre deux fois  moins de temps pour  finir et sera
inactif pendant le reste de la compression.\\
Pour pallier à  ce problème,  il faut découper la  musique en un certain
nombre  de morceaux,  puis  écrire une  fonction qui  va permettre  a un
thread de récupérer le prochain morceau à calculer.  Cette fonction doit
bien  évidement  être  ``thread-safe'',  c'est-à-dire  que  si  elle est
appelée au même moment par plusieurs threads,  elle ne doit pas renvoyer
deux  fois  le  même  morceaux  à  calculer,  ou  avoir  un comportement
indéfini.  Ceci  est  réalisé  en  utilisant  ce  que  l'on  appelle des
``mutex'',  un mutex  possède deux états  : libre  ou bloqué.  Lorsqu'un
thread tente de bloquer un mutex  déjà bloqué,  il attend jusqu'à ce que
ce dernier  devienne  libre.  Leur  utilisation  dans  notre cas devient
alors assez  évidente.  Lorsque la fonction  est appelée,  un  mutex est
bloqué et est libéré lorsque  la fonction se termine,  assurant ainsi le
``thread-safe''.\\
On  pouvait désormais  compresser une  musique de  façon parallèle.  Une
autre utilisation, totalement différente cette fois-ci, était de pouvoir
lire la musique alors que l'on compressait les données.  On a alors deux
threads, totalement séparés, un thread jouant de la musique, et un autre
compressant cette même musique.\\

		\subsubsection{Problèmes rencontrés}
Mais voila,  tout n'est  pas aussi rose dans la  pratique,  si la partie
``thread de lecture et  thread de compression'' fonctionne parfaitement,
il  n'en  est   pas  de  même  pour  la   partie  ``multiple  thread  de
compression''.  Comme dit  précédemment,  la compression est  faites par
Caml et Caml  utilise ce que l'on appelle  un ``Garbage Collector'' pour
gérer la mémoire sans que l'utilisateur  n'ait à se soucier de pointeurs
et autres joyeusetés du genre.  Seulement ce ``Garbage Collector'' n'est
pas  ``thread-safe''\footnote{voir  ci-dessus},   ce  qui  implique  que
lorsque un thread  fait des calculs sur  un une partie de  la musique et
que  l'autre réorganise  la mémoire  à  l'aide  de  ce  fameux ``Garbage
Collector'',  le  premier  va  soudainement  vouloir  écrire  au mauvais
endroit  de   la  mémoire,   en   résulte  une   ``segmentation  fault''
insolvables.\\
Il y a néanmoins une solution pour résoudre ce problème,  que nous avons
partiellement  explorée.  Il s'agit  du  concept  de  ``fork'',  dans un
thread  classique,  chaque thread  partage la  même mémoire,  facilitant
ainsi  les  manipulation  de  la  mémoire,  alors  qu'un  fork  est tout
simplement  un clonage  intégral du  programme.  Les deux  programmes ne
partagent plus la  même zone de mémoire,  ils  sont séparés.  Cela règle
notre problème,  mais ajoute un autre problème, également assez génant :
comment faire  pour partager  une zone  de mémoire?  Car  n'oublions pas
notre but est de partager le  travail sur plusieurs coeur du processeur,
non de faire deux fois le  même travail.  La solution se nomme ``pipe''.
Pour  le moment  cela reste  extrêmement  théorique,  et  par  soucis de
clarté, non implémentée.\\

	\subsection{Interface graphique en GTK}

		\subsubsection{Contrôles utilisateur}

		\subsubsection{Lecture de fichiers ihy}

\section{Tâches prévues}

	\subsection{Ajout du type half}

	\subsection{Utilisation d'autres ondelettes}

	\subsection{Threading total de la compression/décompression}

	\subsection{Amélioration de l'UI}

\newpage

\section*{Conclusion}
Blabla il fait beau ...

\end{document}

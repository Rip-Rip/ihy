\documentclass[a4paper,12pt]{article}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pslatex}
\usepackage{url}
\usepackage{graphicx}
\usepackage{lscape}
\selectlanguage{francais}


\title{Rapport de Soutenance 1}
\author{
Ihy Group : \\
deguil\_x (Xavier Deguillard)\\
genite\_n (Nicolas Geniteau)\\
sezer\_s (Stephane Sezer)\\
wagnac\_t (Teddy Wagnac)
}
\date{10 f\'evrier 2009}

\begin{document}

\maketitle

\newpage

\section*{Introduction}
Nous avons décidé cette année de nous atteler à la réalisation d'un codec audio.
L'orientation principale des projets de spé de cette année étant la recherche et
le développement, nous avons choisi de nous tourner vers les ondelettes qui
seront notre base de travail. En effet, les ondelettes étant un outil
mathématique relativement récent (elles datent du XXème siècle), elles ne sont
pas encore largement utilisées.  Il existe actuellement certains algorithmes de
compression vidéo, par exemple Dirac, leur implémentation par la BBC, mais rien
de probant pour le traitement du signal audio.\\
Notre nouveau codec révolutionnaire (du moins nous l'espérons) se nomme donc le
ihy, pour deux raisons. Premièrement parce qu'``ihy'' est le nom d'un dieu
égyptien de la musique, et deuxièmement parce que ce mot est compliqué à
prononcer.\\
Ceci étant dit, entrons dans le vif du sujet. Nous présenterons dans ce rapport
le travail accompli depuis la validation du cahier des charges, les problèmes
rencontrés et leurs solutions, ainsi que le travail à accomplir pour la
prochaine soutenance.

\newpage

\tableofcontents

\newpage

\section{Travail accompli}

	\subsection{Spécifications du format ihy}
La création d'un nouveau codec passe entre autres par l'écriture des
spécifications du format. Le ihy n'échappe donc pas à la règle.\\
Chaque fichier
ihy contient donc un header composé des quatres lettres SNXT qui sont le FourCC
des fichiers ihy, la taille totale du fichier, le type de compression utilisé
(qui sera utile plus tard lorsque nous aurons plusieurs algorithmes adaptatifs),
le nombre de canaux ainsi que la fréquence.\\
Une deuxième partie contient
différents champs (Artiste, Album, Titre, Année, Genre et Commentaires) qui
servent à décrire le contenu du fichier audio.\\
Vient ensuite la section contenant les données à proprement parler. Cette
section contient une série de chunks décrits par leurs tailles et leurs données
respectives.\\
Ces spécifications suffisent actuellement à nos besoins, mais elles seront très
probablement étendues d'ici la fin de l'année.

	\subsection{Ondelette de Haar}

	\subsection{Interfaçage Caml/C}
Les ondelettes étant faites en Caml, et l'écriture ainsi que divers traitement
réalisés en C, il nous fallait faire transiter des données entre le C et le
Caml. Il y eut plusieurs étapes, envoie de données simple au Caml, puis envois
de données plus complexe et enfin récupération de ces données.\\

		\subsubsection{Envois de données simple}
Il s'agissait de la première étape, pour comprendre comment on devait pour
interfacer le C et le Caml. Notre premier programme fût un simple envoie de
chaine de caractères, et affichage dans la console de cette chaine de
caractère.\\
Le plus dur fût de trouver comment envoyer cette chaine a Caml. Pour cela, il
fallu avant tout déclarer la fonction Caml comme étant utilisable via un
``callback'' :
\begin{verbatim}
let _ =
 Callback.register "print_string" print
\end{verbatim}
Comme vous pouvez le voir, rien de bien difficile à mettre en place,
``print\_string'' était l'identifiant extérieur de la fonction Caml ``print''.
La fonction ``print'' était désormais utilisable de l'extérieur.\\
Il fallait désormais pouvoir l'utiliser à partir du C. Heureusement Caml fournit
des fonctions pour nous aider. Notamment les fonctions :
\begin{verbatim}
CAMLextern value * caml_named_value (char const * name);
CAMLextern value caml_callback (value closure, value arg);
\end{verbatim}
La première renvoie un pointeur sur la fonction Caml correspondant a ``name'',
la seconde appelle la fonction ``closure'' avec comme paramètre ``arg''. Mais
avant de pouvoir utiliser ces fonction, il fallut ``initialiser'' Caml, à l
l'aide de la fonction ``caml\_main'', indispensable pour pouvoir exécuter du
Caml.\\
La dernière chose à faire avant de pouvoir appeler le Caml était de transformer
les types C en type Caml. Cela est géré par le type ``value'' et les fonctions
associées. Après cela, la chaine de caractère était bien affichée par Caml.\\
Comme on peut le voir, la mise en place de l'interface du coté Caml est bien
plus simple que du coté du C.\\

		\subsubsection{Envois et récupération de données complexes}
Maintenant que nous avions envoyer une chaine de caractère, il fallait essayer
d'envoyer des données plus intéressantes pour nous, c'est-à-dire un tableau de
données. Les ``ennuis'' commencèrent. Premièrement, le type ``array'' de Caml
n'est pas compatible avec les tableaux de C, il nous fallu utiliser le module
``Bigarray'' de Caml, qui lui est compatible avec les tableaux du C (il fallait
néanmoins convertir ces derniers en ``value''). Deuxièmement, dès que l'on
touchait au tableau du coté de Caml, le programme avait une ``segmentation
fault'', plutôt gênant\ldots En fait, dans le cas des entiers (plus précisément,
de tout sauf des nombres flottants), Caml les code sur 31bits (sur une
architecture 32bits) et non pas sur 32bits comme le C, il y avait donc un soucis
à l'écriture. Il fallait donc utiliser le type ``Int32'' de Caml pour modifier
le contenu du tableau, le code devient très moche et quasi illisible.
Heureusement pour nous, les ondelettes travaillent sur des nombres flottants qui
est codé de la même façon en C et en Caml.\\
Nous pouvions désormais envoyer des tableaux de flottants à Caml, et Caml
pouvait modifier à sa guise le contenu du tableau. Étape suivante : récupérer le
tableau modifié. Pour cela, rien de bien compliqué, la fonction
``caml\_callback'' vue précédemment nous renvoie sous forme de ``value'' le
résultat de la fonction appelée. Il suffisait désormais de récupérer le tableau
contenu dans le ``value'', et encore une fois Caml fournit une fonction (ou
plutôt une macro ici) : ``Data\_bigarray\_val'' qui renvois le tableau contenu
dans un ``value'' représentant un ``bigarray''.

	\subsection{Algorithme de Huffman}
Algorithme extrêmement utilisé dans le monde de la compression, il doit sa
popularité à son efficacité quelques soit le type de données à compresser. Son
principe est simple, un caractère classique est codé sur un octet ou huit bits,
Huffman considère que les caractères les plus fréquents doivent être codés avec
le moins de bits possible.\\
Dans la pratique, il faut créer ce qu'on appelle un arbre de Huffman, qui est un
arbre binaire localement complet (chaque noeud a soit deux fils soit aucuns),
non équilibré, les caractères sont dans les feuilles de l'arbre et leur nouveau
codage est tout simplement est leur représentation par occurence (on ajoute un 1
a droite du code lorsqu'on part à droite et un 0 lorsqu'on part à gauche, tout
ceci de façon récursive).\\
Au niveau implémentation, il nous a fallu procéder à un comptage des occurrences
de chaque caractère, puis création d'une file de priorités, implémentée grâce à
un tas, ce qui nous assure un ajout et un retrait en temps logarithmique.
Lorsque la file de priorités est créer, il nous faut ensuite construire l'arbre
en tant que tel. Cela se passe en plusieurs étapes :
\begin{enumerate}
\item tant qu'il y a plus d'un élément dans la file :
\begin{enumerate}
\item récupérer les deux élements de plus haute priorité (fréquence la
plus basse).
\item créer un noeud qui a pour fils les deux élements précédent et qui
a pour fréquence la somme de ses deux fils.
\item ajouter ce noeud à la file
\end{enumerate}
\item le dernier noeud est la racine de l'arbre d'Huffman
\end{enumerate}
À partir de cet arbre, on peut déterminer le nouveau codage de chaque caractère,
à l'aide d'un simple parcours profondeur de l'arbre, et à partir du nouveau
codage, on peut déterminer le nouveau fichier compressé.\\
Nous devions régler un dernier soucis : comment lors de la décompression
récupérer le flux original? Il suffit dans la théorie de stocker l'arbre de
Huffman, ou du moins suffisamment de données pour pouvoir le retrouver. La
technique employée ici est assez simple (et peut-être pas optimale) et a le
mérite de marcher. Chaque nœud de l'arbre sera codé sur 2 octets, un octet
indiquant s'il s'agit d'une feuille ou d'un nœud internet, le second octet sert
uniquement pour les feuilles, il indique le caractère correspondant à la
feuille. Ces informations sont écrites suivant leur ordre d'un parcours largeur,
on peut ainsi facilement détecter les changements de niveaux lors de la
décompression.\\
Nous avons réalisé quelques tests, pour évaluer la capacité pour Huffman de
compresser des données. Sur la musique Black Sabbath du groupe éponyme, qui fait
66méga-octets en wav, après passage dans l'algorithme de Huffman, celle-ci ne
fait plus que 55méga-octets, soit 11méga-octets, ou en terme de pourcentage, un
peu moins de 20\%. En sommes, plutôt intéressant.\\

	\subsection{Lecture de son}
La lecture du son, un indispensable lors de la création d'un codec audio, pour
au moins comparer le morceaux initial et celui compressé.\\ Pour cela nous
utilisons une bibliothèque extrêmement simple : libao.  Elle est de plus multi
plateformes et fonctionne donc sur tous les UNIX.  Son fonctionnement est
simple, on récupère le ``device'' audio, correspondant à la sortie audio de
l'ordinateur, puis on indique la taille d'un échantillon, sa fréquence
d'échantillonnage, le nombre de canal\ldots, tout ce qui est nécessaire à la
lecture d'un son. Puis on construit un tableau de caractère, qui est identique
dans sa structure que les données dans un fichier wav, et on peut le jouer. Tout
ça grâce à ces trois fonctions :
\newpage
\begin{verbatim}
void ao_initialize(void);
ao_device* ao_open_live(int driver_id,
 ao_sample_format *format,
 ao_option *option);
int ao_play(ao_device *device,
 char *output_samples,
 uint_32 num_bytes);
\end{verbatim}
Qui servent respectivement à : initialiser le système, ouvrir la carte son pour
pouvoir y lire de la musique, et finalement, lire du son. Rien de plus simple,
bien sur cela impose d'avoir le ``output\_samples'' correctement formé.\\
Grâce à cela, on peut lire un fichier wav sans problèmes, la lecture d'un
fichier ihy n'étant pas encore opérationnelle.\\

	\subsection{Premières étapes de threading}
De nos jours, les processeurs ont de plus de plus de cœurs, ils peuvent donc
exécuter de plus en plus de tâches simultanément, et donc faire des traitements
plus rapides si cette exécution simultanée est bien pensée.\\
La compression audio est particulièrement bien adaptée à cette exécution
simultanée, dites ``concurrentielle''. En effet la compression d'une partie de
la musique ne dépend pas du résultat d'une partie précédente (dans notre cas).
On peut donc mettre en place des ``threads'', un thread permettant cette
execution simultanée au sein d'un même programme, chaque thread calculant une
partie de la musique. Dans la pratique, un thread ne calcule pas uniquement une
partie mais plusieurs petites parties, ceci pour réduire encore la durée d'un
traitement.  Pour illustrer cela, prenons un exemple : utilisons 2 threads et
considérons que la première partie de la musique met deux fois plus de temps que
la deuxième partie. Le premier thread va compresser la première partie, et le
deuxième la deuxième, comme on peut s'en douter, le deuxième thread mettre deux
fois moins de temps pour finir et sera inactif pendant le reste de la
compression.\\
Pour pallier à ce problème, il faut découper la musique en un certain nombre de
morceaux, puis écrire une fonction qui va permettre a un thread de récupérer le
prochain morceau à calculer. Cette fonction doit bien évidement être
``thread-safe'', c'est-à-dire que si elle est appelée au même moment par
plusieurs threads, elle ne doit pas renvoyer deux fois le même morceaux à
calculer, ou avoir un comportement indéfini. Ceci est réalisé en utilisant ce
que l'on appelle des ``mutex'', un mutex possède deux états : libre ou bloqué.
Lorsqu'un thread tente de bloquer un mutex déjà bloqué, il attend jusqu'à ce que
ce dernier devienne libre. Leur utilisation dans notre cas devient alors assez
évidente. Lorsque la fonction est appelée, un mutex est bloqué et est libéré
lorsque la fonction se termine, assurant ainsi le ``thread-safe''.\\
On pouvait désormais compresser une musique de façon parallèle. Une autre
utilisation, totalement différente cette fois-ci, était de pouvoir lire la
musique alors que l'on compressait les données. On a alors deux threads,
totalement séparés, un thread jouant de la musique, et un autre compressant
cette même musique.\\

		\subsubsection{Problèmes rencontrés}
Mais voila, tout n'est pas aussi rose dans la pratique, si la partie ``thread de
lecture et thread de compression'' fonctionne parfaitement, il n'en est pas de
même pour la partie ``multiple thread de compression''. Comme dit précédemment,
la compression est faites par Caml et Caml utilise ce que l'on appelle un
``Garbage Collector'' pour gérer la mémoire sans que l'utilisateur n'ait à se
soucier de pointeurs et autres joyeusetés du genre. Seulement ce ``Garbage
Collector'' n'est pas ``thread-safe''\footnote{voir ci-dessus}, ce qui implique
que lorsque un thread fait des calculs sur un une partie de la musique et que
l'autre réorganise la mémoire à l'aide de ce fameux ``Garbage Collector'', le
premier va soudainement vouloir écrire au mauvais endroit de la mémoire, en
résulte une ``segmentation fault'' insolvables.\\
Il y a néanmoins une solution pour résoudre ce problème, que nous avons
partiellement explorée. Il s'agit du concept de ``fork'', dans un thread
classique, chaque thread partage la même mémoire, facilitant ainsi les
manipulation de la mémoire, alors qu'un fork est tout simplement un clonage
intégral du programme. Les deux programmes ne partagent plus la même zone de
mémoire, ils sont séparés. Cela règle notre problème, mais ajoute un autre
problème, également assez génant : comment faire pour partager une zone de
mémoire? Car n'oublions pas notre but est de partager le travail sur plusieurs
coeur du processeur, non de faire deux fois le même travail. La solution se
nomme ``pipe''.  Pour le moment cela reste extrêmement théorique, et par soucis
de clarté, non implémentée.\\

	\subsection{Ce que notre programme fait}
Pour le moment, notre programme réalise plusieurs choses. Premièrement, il lit
un fichier wav et le place en mémoire, il s'agit du premier argument de notre
programme. À partir de ce fichier wav, il le joue en arrière plan. Il applique
ensuite les ondelettes sur ce fichier et l'écrit dans un fichier passé en
deuxième paramètre. Nous appliquons ensuite l'algorithme de Huffman sur le
fichier wav et mesurons la différence entre le fichier original et le fichier
``compressé'', ceci pour évaluer la performance de cet algorithme. Puis, à
partir du fichier ihy précédemment créer, nous appliquons les ``ondelettes
inverses'' et écrivons le fichier wav ainsi obtenu dans le troisième argument du
programme.\\

	\subsection{Interface graphique en GTK}

		\subsubsection{Petite présentation de GTK+}
La bibliothèque GTK+ permet de créer des interfaces graphiques (GUI) assez
simplement. C'est pour cela que nous avons choisi cette librairie, afin de
développer une interface graphique interactive et attrayante. A l'origine, GTK+
a été développée pour donner des bases solides au logiciel de traitement
d'images GIMP (GNU Image Manipulation Program). Aujourd'hui, le domaine
d'application de cette bibliothèque ne se limite pas à GIMP : elle est utilisée
dans d'autres projets. Le développement phare est l'environnement  GNOME (GNU
Network Object Model Environment).

		\subsubsection{Notre lecteur Ihy}
Tout d'abord, avant de développer l'interface idéale il fallait nous
familiariser avec GTK et son principe de widget (Window Gadget) qui sont les
objets graphique de GTK+. Un widget est en fait une structure définissant les
propriétés d'un objet associé à une large panoplie de fonctions permettant de
manipuler ces objets. Donc, nous avons décidé de commencer en développant une
fenêtre de base qui représente notre futur lecteur audio. En effet, nous avons
une fenêtre de dimension 620x400 pouvant apparaitre à un endroit aléatoire sur
le bureau avec les trois icônes de base qui permettent de fermer, réduire et
restaurer la fenêtre. De plus, la fenêtre contient un titre « Lecteur Ihy ».  La
fenêtre contient deux box. Une Box permet d'inclure plusieurs widgets à
l'intérieur d'une fenêtre, sans ça il est strictement impossible de le faire.
Pour notre part, nous détenons 2 Box. Une Box verticale (GtkVBox) qui permet de
disposer les widgets verticalement, qui elle contient une Box horizontale
(GtkHBox) qui dispose les widgets horizontalement. La Box horizontale contient
cinq boutons. Les cinq boutons indispensable pour un lecteur audio, c'est-à-dire
PLAY, STOP, PAUSE, AVANCE et RETOUR. Chacun de ces boutons viennent du stock
direct de GTK+ qui est pour sa part plutôt vaste. Les cinq boutons sont
positionnés horizontalement comme dis précédemment, de même dimension et ce
partage l'espace équitablement selon le principe de la Box dans GTK.  Tandis
que, la Box verticale, en plus de détenir la Box horizontale, détient une barre
de progression, qui se remplit à l'aide d'un clic sur le bouton PLAY. Pour
cela, on utilise une fonction de GTK+ qui permet de faire une seul itération.
Donc à ce moment là GTK+ va reprendre la main puis la rendre aussitôt, si bien
qu’il pourra mettre à jour les widgets.  Voilà en quelques termes ce que
nous avons pour notre première ébauche. Pour la prochaine fois, nous comptons
rendre notre lecteur plus attractif et tenter de le faire paraitre plus comme un
lecteur audio. Pour cela, nous comptons utiliser des tables qui permettes dans
GTK+ de mieux placer les widgets dans les Box afin d'avoir plus de précision. 

\section{Tâches prévues}

	\subsection{Ajout du type half}
Un des gros problèmes que nous avons actuellement réside dans le fait que la
plupart des échantillons dans un fichier pcm sont codés sur 16 bits, et qu'un
floattant, par défaut est codé sur 32 bits. Sachant que nous n'utilisons
actuellement aucune méthode d'éliminitation des données, nous obtenons un
fichier ihy qui fait précisément deux fois la taille du fichier pcm original
(modulo la taille des headers).\\
Il est aisé de comprendre que c'est un petit peu embêtant pour un format de
compression audio\ldots\\
Un format qui est actuellement dans un draft de la prochaine spécification
IEEE754 est le half precision floating point number. En effet, comme son nom
l'indique, ce type de données utilise 16bits pour stocker un nombre à virgule
flotante. Le resultat obtenu lors d'un traitement avec les ondelettes n'ayant
pas besoin de la précision apportée par les flottants 32bits, ce format est
farpaitement\footnote{Voir Asterix \& Obélix, les lauriers de César} adapté à nos
besoins.\\
Le souci réside dans le fait que ce format n'est ni utilisé dans les processeurs
x86 actuels (il le sera probablement avec les instructions SSE5), ni utilisable
en C. ll nous faudra donc l'implémenter nous même et écrire les fonctions de
conversions half\_to\_float et float\_to\_half correspondantes.

	\subsection{Utilisation d'autres ondelettes}

	\subsection{Threading total de la compression/décompression}

	\subsection{Amélioration de l'UI}

\newpage

\section*{Conclusion}
Blabla il fait beau... (trop pas mec !)

\end{document}
